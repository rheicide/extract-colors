"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});function t({pixels:t=64e3,distance:s=.22,colorValidator:e=(t,s,e,r)=>(r??255)>250,hueDistance:r=.08333333333333333,saturationDistance:o=.2,lightnessDistance:n=.2,crossOrigin:i="",requestMode:a="cors"}={}){const c=(t,s,e=0,r=Number.MAX_VALUE)=>{if(Number(s)!==s)throw new Error(`${t} is not a valid number (${s})`);return s<e&&console.warn(`${t} can not be less than ${e} (it's ${s})`),s>r&&console.warn(`${t} can not be more than ${r} (it's ${s})`),Math.min(Math.max(s,e),r)},h=(t,s,e)=>{e.indexOf(s)<0&&console.warn(`${t} can be one of this values ${e.map((t=>`"${t}"`)).join(", ")} (it's "${s}")`)};((t,s,e=0,r=Number.MAX_SAFE_INTEGER)=>{if(!Number.isInteger(s))throw new Error(`${t} is not a valid number (${s})`);s<e&&console.warn(`${t} can not be less than ${e} (it's ${s})`),s>r&&console.warn(`${t} can not be more than ${r} (it's ${s})`),Math.min(Math.max(s,e),r)})("pixels",t||0,1),c("distance",s,0,1),((t,s)=>{if(!s||"[object Function]"!=={}.toString.call(s))throw new Error(`${t} is not a function (${s})`)})("colorValidator",e),c("hueDistance",r,0,1),c("saturationDistance",o,0,1),c("lightnessDistance",n,0,1),h("crossOrigin",i,["","anonymous","use-credentials"]),h("requestMode",a,["cors","navigate","no-cors","same-origin"])}const s=({pixels:t=64e3,distance:s=.22,colorValidator:e=(t,s,e,r)=>(r??255)>250,hueDistance:r=.08333333333333333,saturationDistance:o=.2,lightnessDistance:n=.2,crossOrigin:i="",requestMode:a="cors"}={})=>[Math.max(t,1),Math.min(Math.max(s,0),1),e,Math.min(Math.max(r,0),1),Math.min(Math.max(o,0),1),Math.min(Math.max(n,0),1),i,a];class e{constructor(t,s,e,r=t<<16|s<<8|e){this.t=1,this.o=-1,this.i=-1,this.h=-1,this.u=-1,this.l=t,this._=s,this.m=e,this.M=r}static distance(t,s){return(Math.abs(s.l-t.l)+Math.abs(s._-t._)+Math.abs(s.m-t.m))/765}clone(){const t=new e(this.l,this._,this.m,this.M);return t.t=this.t,t}p(){const t=this.l/255,s=this._/255,e=this.m/255,r=Math.max(t,s,e),o=Math.min(t,s,e);if(this.h=(r+o)/2,r===o)this.i=0,this.o=0,this.u=0;else{const n=r-o;switch(this.o=this.h>.5?n/(2-r-o):n/(r+o),this.u=this.o*(2*(.5-Math.abs(.5-this.h))),r){case t:this.i=((s-e)/n+(s<e?6:0))/6;break;case s:this.i=((e-t)/n+2)/6;break;case e:this.i=((t-s)/n+4)/6}}}get D(){return-1===this.i&&this.p(),this.i}get $(){return-1===this.o&&this.p(),this.o}get C(){return-1===this.h&&this.p(),this.h}get V(){return-1===this.u&&this.p(),this.u}}class r{constructor(){this.t=0,this.j={}}I(t,s,r,o){return this.t++,this.j[t]?this.j[t].t++:this.j[t]=new e(s,r,o,t),this.j[t]}O(){return Object.keys(this.j).map((t=>this.j[t]))}v(){const t=this.O().reduce(((t,s)=>t.t>=s.t?t:s)).clone();return t.t=this.t,t}}class o{constructor(){this.t=0,this.j={}}O(){return Object.keys(this.j).map((t=>this.j[t]))}I(t,s,e){const r=t<<16|s<<8|e,o=(t>>4&15)<<8|(s>>4&15)<<4|e>>4&15;return this.t++,this.N(o).I(r,t,s,e)}N(t){return this.j[t]||(this.j[t]=new r),this.j[t]}L(t){const s=this.O().map((t=>t.v()));s.sort(((t,s)=>s.t-t.t));const r=[];for(;s.length;){const o=s.shift();s.filter((s=>e.distance(o,s)<t)).forEach((t=>{o.t+=t.t;const e=s.findIndex((s=>s===t));s.splice(e,1)})),r.push(o)}return r}}const n=({data:t,width:s,height:e},r,n,i)=>{const a=new o,c=s&&e&&Math.floor(s*e/r)||1;let h=0;for(let o=0;o<t.length;o+=4*c){const s=t[o],e=t[o+1],r=t[o+2];i(s,e,r,t[o+3])?a.I(s,e,r):h++}return{S:a.L(n),count:a.t+h}},i=(t,s)=>Math.abs(t-s);class a{constructor(){this.S=[],this.k=null}I(t){this.S.push(t),this.k=null}H(t,s,e,r){for(const a of this.S){if(!(o=a.D,n=t.D,Math.min(i(o,n),i((o+.5)%1,(n+.5)%1))<s&&i(a.$,t.$)<e&&i(a.C,t.C)<r))return!1}var o,n;return!0}get q(){if(!this.k){const{r:t,g:s,b:r}=this.S.reduce(((t,s)=>(t.r+=s.l,t.g+=s._,t.b+=s.m,t)),{r:0,g:0,b:0}),o=this.S.reduce(((t,s)=>t+s.t),0);this.k=new e(Math.round(t/this.S.length),Math.round(s/this.S.length),Math.round(r/this.S.length)),this.k.t=o}return this.k}}class c{constructor(t,s,e){this.P=[],this.D=t,this.$=s,this.C=e}I(t){const s=this.P.find((s=>s.H(t,this.D,this.$,this.C)));if(s)s.I(t);else{const s=new a;s.I(t),this.P.push(s)}}F(){return this.P.map((t=>t.q))}}const h=()=>"object"==typeof self&&self.constructor&&"DedicatedWorkerGlobalScope"===self.constructor.name,u=()=>"undefined"==typeof window&&"undefined"!=typeof process&&null!=process.versions&&null!=process.versions.node,l=(t,s,e,r,o)=>{const n=((t,s,e,r,o)=>{const n=new c(e,r,o);t.forEach((t=>n.I(t)));const i=n.F();return i.sort(((t,e)=>(e.V+.1)*(.9-e.t/s)-(t.V+.1)*(.9-t.t/s))),i})(t,s,e,r,o);return n.map((t=>((t,s)=>({hex:`#${"0".repeat(6-t.M.toString(16).length)}${t.M.toString(16)}`,red:t.l,green:t._,blue:t.m,area:t.t/s,hue:t.D,saturation:t.$,lightness:t.C,intensity:t.V}))(t,s)))},d=(t,s)=>{const e="naturalWidth"in t?t.naturalWidth:t.width,r="naturalHeight"in t?t.naturalHeight:t.height,o=e*r,n=o<s?e:Math.round(e*Math.sqrt(s/o)),i=o<s?r:Math.round(r*Math.sqrt(s/o)),a=((t,s)=>{if(h())return new OffscreenCanvas(t,s);const e=document.createElement("canvas");return e.width=t,e.height=s,e})(n,i).getContext("2d");return a.drawImage(t,0,0,e,r,0,0,n,i),a.getImageData(0,0,n,i)},f=(e,r={})=>{process.env.NODE_ENV !== "production"&&t(r);const[o,i,a,c,h,u]=s(r),{S:d,count:f}=n(e,o,i,a);return l(d,f,c,h,u)},_=async(e,r={})=>{if(u()){if(process.env.NODE_ENV !== "production")throw new Error("Use extractColors instead extractColorsFromImage for Node.js");return[]}process.env.NODE_ENV !== "production"&&t(r);const[o,i,a,c,h,f,_]=s(r);return e.crossOrigin=_,new Promise((t=>{const s=s=>{const e=d(s,o),{S:r,count:u}=n(e,o,i,a);t(l(r,u,c,h,f))};if(e.complete)s(e);else{const t=()=>{e.removeEventListener("load",t),s(e)};e.addEventListener("load",t)}}))},g=async(e,r={})=>{if(u()){if(process.env.NODE_ENV !== "production")throw new Error("Use extractColors instead extractColorsFromImageBitmap for Node.js");return[]}process.env.NODE_ENV !== "production"&&t(r);const[o,i,a,c,h,f]=s(r),_=d(e,o),{S:g,count:w}=n(_,o,i,a);return l(g,w,c,h,f)},w=async(e,r={})=>{if(u()){if(process.env.NODE_ENV !== "production")throw new Error("Can not use extractColorsFromSrc for Node.js");return[]}if(process.env.NODE_ENV !== "production"&&t(r),h()){const t=s(r),o=await fetch(e,{mode:t[7]}),n=await o.blob(),i=await createImageBitmap(n),a=await g(i,r);return i.close(),a}const o=new Image;return o.src=e,_(o,r)};exports.extractColors=(t,s)=>{if("undefined"!=typeof window&&void 0!==window.document){if(process.env.NODE_ENV !== "production"&&s?.requestMode&&console.warn("options.requestMode not supported in Browser, use options.crossOrigin instead"),t instanceof Image)return _(t,s);if(t instanceof ImageData||t instanceof Object&&t.data)return new Promise((e=>{e(f(t,s))}));if("string"==typeof t)return w(t,s)}if(h()){if(process.env.NODE_ENV !== "production"&&s?.crossOrigin&&console.warn("options.crossOrigin not supported in Web Worker, use options.requestMode instead"),t instanceof ImageData||t instanceof Object&&t.data)return new Promise((e=>{e(f(t,s))}));if("string"==typeof t)return w(t,s);if(t.src)return process.env.NODE_ENV !== "production"&&console.warn("HTMLImageElement not enable on worker, a fallback is used to extract src from your HTMLImageElement, please send 'src' instead HTMLImageElement"),w(t.src,s)}if(u()){if(process.env.NODE_ENV !== "production"){if(t instanceof String)throw new Error("Send imageData to extractColors (Image src or HTMLImageElement not supported in Nodejs)");if(!t.data)throw new Error("Send imageData to extractColors");s?.crossOrigin&&console.warn("options.crossOrigin not supported in Node.js")}return new Promise((e=>{e(f(t,s))}))}throw new Error("Can not analyse picture")},exports.extractColorsFromImage=_,exports.extractColorsFromImageBitmap=g,exports.extractColorsFromImageData=f,exports.extractColorsFromSrc=w;
//# sourceMappingURL=extract-colors.cjs.map
