function t({pixels:t=64e3,distance:s=.22,colorValidator:e=(t,s,e,n)=>(n??255)>250,hueDistance:n=.08333333333333333,saturationDistance:r=.2,lightnessDistance:o=.2,crossOrigin:i="",requestMode:a="cors"}={}){const h=(t,s,e=0,n=Number.MAX_VALUE)=>{if(Number(s)!==s)throw new Error(`${t} is not a valid number (${s})`);return s<e&&console.warn(`${t} can not be less than ${e} (it's ${s})`),s>n&&console.warn(`${t} can not be more than ${n} (it's ${s})`),Math.min(Math.max(s,e),n)},c=(t,s,e)=>{e.indexOf(s)<0&&console.warn(`${t} can be one of this values ${e.map((t=>`"${t}"`)).join(", ")} (it's "${s}")`)};((t,s,e=0,n=Number.MAX_SAFE_INTEGER)=>{if(!Number.isInteger(s))throw new Error(`${t} is not a valid number (${s})`);s<e&&console.warn(`${t} can not be less than ${e} (it's ${s})`),s>n&&console.warn(`${t} can not be more than ${n} (it's ${s})`),Math.min(Math.max(s,e),n)})("pixels",t||0,1),h("distance",s,0,1),((t,s)=>{if(!s||"[object Function]"!=={}.toString.call(s))throw new Error(`${t} is not a function (${s})`)})("colorValidator",e),h("hueDistance",n,0,1),h("saturationDistance",r,0,1),h("lightnessDistance",o,0,1),c("crossOrigin",i,["","anonymous","use-credentials"]),c("requestMode",a,["cors","navigate","no-cors","same-origin"])}const s=({pixels:t=64e3,distance:s=.22,colorValidator:e=(t,s,e,n)=>(n??255)>250,hueDistance:n=.08333333333333333,saturationDistance:r=.2,lightnessDistance:o=.2,crossOrigin:i="",requestMode:a="cors"}={})=>[Math.max(t,1),Math.min(Math.max(s,0),1),e,Math.min(Math.max(n,0),1),Math.min(Math.max(r,0),1),Math.min(Math.max(o,0),1),i,a];class e{constructor(t,s,e,n=t<<16|s<<8|e){this.t=1,this.o=-1,this.i=-1,this.h=-1,this.u=-1,this.l=t,this._=s,this.m=e,this.M=n}static distance(t,s){return(Math.abs(s.l-t.l)+Math.abs(s._-t._)+Math.abs(s.m-t.m))/765}clone(){const t=new e(this.l,this._,this.m,this.M);return t.t=this.t,t}p(){const t=this.l/255,s=this._/255,e=this.m/255,n=Math.max(t,s,e),r=Math.min(t,s,e);if(this.h=(n+r)/2,n===r)this.i=0,this.o=0,this.u=0;else{const o=n-r;switch(this.o=this.h>.5?o/(2-n-r):o/(n+r),this.u=this.o*(2*(.5-Math.abs(.5-this.h))),n){case t:this.i=((s-e)/o+(s<e?6:0))/6;break;case s:this.i=((e-t)/o+2)/6;break;case e:this.i=((t-s)/o+4)/6}}}get D(){return-1===this.i&&this.p(),this.i}get $(){return-1===this.o&&this.p(),this.o}get C(){return-1===this.h&&this.p(),this.h}get V(){return-1===this.u&&this.p(),this.u}}class n{constructor(){this.t=0,this.I={}}j(t,s,n,r){return this.t++,this.I[t]?this.I[t].t++:this.I[t]=new e(s,n,r,t),this.I[t]}O(){return Object.keys(this.I).map((t=>this.I[t]))}v(){const t=this.O().reduce(((t,s)=>t.t>=s.t?t:s)).clone();return t.t=this.t,t}}class r{constructor(){this.t=0,this.I={}}O(){return Object.keys(this.I).map((t=>this.I[t]))}j(t,s,e){const n=t<<16|s<<8|e,r=(t>>4&15)<<8|(s>>4&15)<<4|e>>4&15;return this.t++,this.N(r).j(n,t,s,e)}N(t){return this.I[t]||(this.I[t]=new n),this.I[t]}L(t){const s=this.O().map((t=>t.v()));s.sort(((t,s)=>s.t-t.t));const n=[];for(;s.length;){const r=s.shift();s.filter((s=>e.distance(r,s)<t)).forEach((t=>{r.t+=t.t;const e=s.findIndex((s=>s===t));s.splice(e,1)})),n.push(r)}return n}}const o=({data:t,width:s,height:e},n,o,i)=>{const a=new r,h=s&&e&&Math.floor(s*e/n)||1;let c=0;for(let r=0;r<t.length;r+=4*h){const s=t[r],e=t[r+1],n=t[r+2];i(s,e,n,t[r+3])?a.j(s,e,n):c++}return{S:a.L(o),count:a.t+c}},i=(t,s)=>Math.abs(t-s);class a{constructor(){this.S=[],this.k=null}j(t){this.S.push(t),this.k=null}H(t,s,e,n){for(const a of this.S){if(!(r=a.D,o=t.D,Math.min(i(r,o),i((r+.5)%1,(o+.5)%1))<s&&i(a.$,t.$)<e&&i(a.C,t.C)<n))return!1}var r,o;return!0}get q(){if(!this.k){const{r:t,g:s,b:n}=this.S.reduce(((t,s)=>(t.r+=s.l,t.g+=s._,t.b+=s.m,t)),{r:0,g:0,b:0}),r=this.S.reduce(((t,s)=>t+s.t),0);this.k=new e(Math.round(t/this.S.length),Math.round(s/this.S.length),Math.round(n/this.S.length)),this.k.t=r}return this.k}}class h{constructor(t,s,e){this.P=[],this.D=t,this.$=s,this.C=e}j(t){const s=this.P.find((s=>s.H(t,this.D,this.$,this.C)));if(s)s.j(t);else{const s=new a;s.j(t),this.P.push(s)}}F(){return this.P.map((t=>t.q))}}const c=()=>"object"==typeof self&&self.constructor&&"DedicatedWorkerGlobalScope"===self.constructor.name,u=()=>"undefined"==typeof window&&"undefined"!=typeof process&&null!=process.versions&&null!=process.versions.node,l=(t,s,e,n,r)=>{const o=((t,s,e,n,r)=>{const o=new h(e,n,r);t.forEach((t=>o.j(t)));const i=o.F();return i.sort(((t,e)=>(e.V+.1)*(.9-e.t/s)-(t.V+.1)*(.9-t.t/s))),i})(t,s,e,n,r);return o.map((t=>((t,s)=>({hex:`#${"0".repeat(6-t.M.toString(16).length)}${t.M.toString(16)}`,red:t.l,green:t._,blue:t.m,area:t.t/s,hue:t.D,saturation:t.$,lightness:t.C,intensity:t.V}))(t,s)))},d=(t,s)=>{const e="naturalWidth"in t?t.naturalWidth:t.width,n="naturalHeight"in t?t.naturalHeight:t.height,r=e*n,o=r<s?e:Math.round(e*Math.sqrt(s/r)),i=r<s?n:Math.round(n*Math.sqrt(s/r)),a=((t,s)=>{if(c())return new OffscreenCanvas(t,s);const e=document.createElement("canvas");return e.width=t,e.height=s,e})(o,i).getContext("2d");return a.drawImage(t,0,0,e,n,0,0,o,i),a.getImageData(0,0,o,i)},f=(e,n={})=>{process.env.NODE_ENV !== "production"&&t(n);const[r,i,a,h,c,u]=s(n),{S:d,count:f}=o(e,r,i,a);return l(d,f,h,c,u)},_=async(e,n={})=>{if(u()){if(process.env.NODE_ENV !== "production")throw new Error("Use extractColors instead extractColorsFromImage for Node.js");return[]}process.env.NODE_ENV !== "production"&&t(n);const[r,i,a,h,c,f,_]=s(n);return e.crossOrigin=_,new Promise((t=>{const s=s=>{const e=d(s,r),{S:n,count:u}=o(e,r,i,a);t(l(n,u,h,c,f))};if(e.complete)s(e);else{const t=()=>{e.removeEventListener("load",t),s(e)};e.addEventListener("load",t)}}))},g=async(e,n={})=>{if(u()){if(process.env.NODE_ENV !== "production")throw new Error("Use extractColors instead extractColorsFromImageBitmap for Node.js");return[]}process.env.NODE_ENV !== "production"&&t(n);const[r,i,a,h,c,f]=s(n),_=d(e,r),{S:g,count:w}=o(_,r,i,a);return l(g,w,h,c,f)},w=async(e,n={})=>{if(u()){if(process.env.NODE_ENV !== "production")throw new Error("Can not use extractColorsFromSrc for Node.js");return[]}if(process.env.NODE_ENV !== "production"&&t(n),c()){const t=s(n),r=await fetch(e,{mode:t[7]}),o=await r.blob(),i=await createImageBitmap(o),a=await g(i,n);return i.close(),a}const r=new Image;return r.src=e,_(r,n)},m=(t,s)=>{if("undefined"!=typeof window&&void 0!==window.document){if(process.env.NODE_ENV !== "production"&&s?.requestMode&&console.warn("options.requestMode not supported in Browser, use options.crossOrigin instead"),t instanceof Image)return _(t,s);if(t instanceof ImageData||t instanceof Object&&t.data)return new Promise((e=>{e(f(t,s))}));if("string"==typeof t)return w(t,s)}if(c()){if(process.env.NODE_ENV !== "production"&&s?.crossOrigin&&console.warn("options.crossOrigin not supported in Web Worker, use options.requestMode instead"),t instanceof ImageData||t instanceof Object&&t.data)return new Promise((e=>{e(f(t,s))}));if("string"==typeof t)return w(t,s);if(t.src)return process.env.NODE_ENV !== "production"&&console.warn("HTMLImageElement not enable on worker, a fallback is used to extract src from your HTMLImageElement, please send 'src' instead HTMLImageElement"),w(t.src,s)}if(u()){if(process.env.NODE_ENV !== "production"){if(t instanceof String)throw new Error("Send imageData to extractColors (Image src or HTMLImageElement not supported in Nodejs)");if(!t.data)throw new Error("Send imageData to extractColors");s?.crossOrigin&&console.warn("options.crossOrigin not supported in Node.js")}return new Promise((e=>{e(f(t,s))}))}throw new Error("Can not analyse picture")};export{m as extractColors,_ as extractColorsFromImage,g as extractColorsFromImageBitmap,f as extractColorsFromImageData,w as extractColorsFromSrc};
//# sourceMappingURL=extract-colors.mjs.map
